# Kotlin coroutine



## dispatcher, suspend以及Continutation

主线程：386旅独立团

李云龙就是：默认的dispatcher

当前线程在执行代码，可以看成李云龙的独立团在执行任务。

但是有很多具体的耗时的任务，不可能什么事都团长亲力亲为，否则就会像诸葛亮一样活活累死了。

所以他需要各大营长的帮助，营长就是其他的dispatcher。

比如：

攻打平安县城的时候，团长说：二营长，把你的意大利炮拿出来。

翻译成代码就是：

```
lauch(Dispatchers.李云龙){
	suspendingGet意大利炮()
	开炮（）
}
```

这时候，二营长（dispatcher）指引着二营的人就去执行耗时任务，推意大利炮。

独立团（主线程）只能等着意大利炮被送过来了，才能继续打县城。

Suspend 是干嘛的呢，就相当于是一个军令状，就是李云龙的手书，上面写着李云龙交代给二营长要做的事情所以上面肯定有两个东西：

```
执行人：二营长
执行命令：get意大利炮
```

所以你要这么写：

```
Suspend fun suspendingGet意大利炮(){
	withContext(Dispatchers.二营长)
	get意大利炮（）
}
```

但是如果少一个怎么办，比如说忘了写二营长了。

```
Suspend fun suspendingGet意大利炮(){
	get意大利炮（）
}
```

那就没人执行命令，因为大家都不知道这东西应该谁去做，所以最后就只能李云龙（当前线程）做了。

Suspend同时也意味着这是一个耗时任务，需要营长（协程）去干，不可能说：”二营长，帮我洗脚（刷新UI）“这样的任务也分出去做。

至于二营长，他乖乖的去拿意大利炮，拿到手之后，肯定还要回到独立团，不可能跑路，毕竟他只是一个营长（协程），最终依附于团长（当前线程）。除非有更高级的命令，让他一去不回了。所以协程的代码执行完后，肯定有切回现在线程了。

至于为啥营长他总能准确的回到团部呢？这就靠`Continutation`了，这相当于军令状上面的印章，就是当协程创建的时候，这个玩意就有了，主要就是说明这个任务是我李云龙发的，你小子干完事别忘了回家，相当于代替了Callback的作用。

再举个例子就是：

李云龙：一营包围李家镇，二营进去捞娘们。

```
lauch(Dispatchers.李云龙){
	suspending包围李家镇()
	...
}
suspend fun suspending包围李家镇(){
	withContext(Dispatchers.一营长)
}
lauch(Dispatchers.李云龙){
	suspending捞娘们()
	...
}
suspend fun suspending捞娘们(){
	withContext(Dispatchers.二营长)
}
```

当然营长也可以让自己得连长去干脏活累活，也能说明每一个被`suspend`修饰的方法都必须在另一个`suspend`函数或者`Coroutine`协程程序中进行调用。

## GlobalScope.launch 和 runBlocking

GlobalScope 看名字就知道不简单，可以把他想象成旅长。

GlobalScope.launch创建一个协程，就相当于旅长下命令了，所以这个命令，独立团就算拼到了最后一个人也得去执行。

为啥大家都不让用呢？

举个简单得例子：

蒋委员长最喜欢长臂管辖，越级指挥，他的每一道命令都可以当作一个GlobalScope。

```
千里之外，正在作战的楚云飞。
“喂？校长？怎么了？”
“把你三营四连二排的机枪手，往前挪二十米。”
“... ...”
半小时后，楚云飞全军覆没，电话还在响。
“喂？你挪了没？”
```

